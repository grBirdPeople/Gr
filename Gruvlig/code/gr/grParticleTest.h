#ifndef		_GRPARTICLETEST_H_
#define		_GRPARTICLETEST_H_

#include	"grCommon.h"
#include	"grV2.h"
#include	"grRandom.h"
#include	"grMath.h"
#include	"grAlgo.h"


////////////////////////////////////////////////////////////////////////////////////////////////////
struct grSColor
{
	grSColor( intU r = 255, intU g = 255, intU b = 255, intU a = 255 )
		: R( r )
		, G( g )
		, B( b )
		, A( a )
	{}

	intU R, G, B, A;
};

////////////////////////////////////////////////////////////////////////////////////////////////////
struct grSParticle
{
	grSParticle( const sizeT size )
		: puColorStart		( std::make_unique<grSColor[]>( size ) )
		, puColorEnd		( std::make_unique<grSColor[]>( size ) )
		, puScale			( std::make_unique<grV2f[]>( size ) )		
		, puAcceleration	( std::make_unique<grV2f[]>( size ) )
		, puVelocity		( std::make_unique<grV2f[]>( size ) )
		, puPosition		( std::make_unique<grV2f[]>( size ) )
		, puMass			( std::make_unique<float[]>( size ) )
		, puLife			( std::make_unique<float[]>( size ) )
		, Alive				( 0 )
	{
		for( sizeT i = 0; i < size; ++i )
			puMass[ i ] = 1.0f;
	}
	grSParticle( const grSParticle& ) = delete;
	grSParticle& operator=( const grSParticle& ) = delete;

	void Kill( const sizeT nowIdx )
	{
		sizeT last = Alive - 1;

		//for( sizeT i = 0; i < rParticle->Alive + 1; ++i )
		//	printf( "%d %3s %g \n", i, "", rParticle->puLife[ i ] );

		grAlgo::Swap( puColorStart[ nowIdx ], puColorStart[ last ] );
		grAlgo::Swap( puColorEnd[ nowIdx ], puColorEnd[ last ] );
		grAlgo::Swap( puScale[ nowIdx ], puScale[ last ] );
		grAlgo::Swap( puAcceleration[ nowIdx ], puAcceleration[ last ] );
		grAlgo::Swap( puVelocity[ nowIdx ], puVelocity[ last ] );
		grAlgo::Swap( puPosition[ nowIdx ], puPosition[ last ] );
		grAlgo::Swap( puMass[ nowIdx ], puMass[ last ] );
		grAlgo::Swap( puLife[ nowIdx ], puLife[ last ] );

		// Most values are generated by operator= and does not need zeroing
		// Values that are generated with operator+= needs resetting obviously

		puAcceleration[ last ] = grV2f();

		//for ( sizeT i = 0; i < rParticle->Alive + 1; ++i )
		//	printf( "%d %3s %g \n", i, "", rParticle->puLife[ i ] );

		--Alive;
	}

	pU<grSColor[]>	puColorStart;
	pU<grSColor[]>	puColorEnd; // TODO: Don't like this one. Figure out how to communicate start and end colors to the updater without binding
	pU<grV2f[]>		puScale;
	pU<grV2f[]>		puAcceleration;
	pU<grV2f[]>		puVelocity;
	pU<grV2f[]>		puPosition;
	pU<float[]>		puMass;
	pU<float[]>		puLife;

	sizeT	Alive;
};

////////////////////////////////////////////////////////////////////////////////////////////////////
struct grSGeneratorBase
{
	enum class EEqual
	{
		NO = 0,
		YES = 1
	};

	void SetBase( grSColor& rStart, grSColor& rEnd )
	{
		rStart.R = grMath::Clamp( rStart.R, 0, 255 );
		rStart.G = grMath::Clamp( rStart.G, 0, 255 );
		rStart.B = grMath::Clamp( rStart.B, 0, 255 );
		rStart.A = grMath::Clamp( rStart.A, 0, 255 );

		rEnd.R = grMath::Clamp( rEnd.R, 0, 255 );
		rEnd.G = grMath::Clamp( rEnd.G, 0, 255 );
		rEnd.B = grMath::Clamp( rEnd.B, 0, 255 );
		rEnd.A = grMath::Clamp( rEnd.A, 0, 255 );

		if ( grMath::CmpIntU( rStart.R, rEnd.R ) &&
			 grMath::CmpIntU( rStart.G, rEnd.G ) &&
			 grMath::CmpIntU( rStart.B, rEnd.B ) &&
			 grMath::CmpIntU( rStart.A, rEnd.A ) )
		{
			Equal = EEqual::YES;
		}
	}

	void SetBase( grV2f& rMin, grV2f& rMax )
	{
		grMath::RangeCheckV2fx2( rMin, rMax );
		Equal = grMath::CmpV2f( rMin, rMax ) ? EEqual::YES : EEqual::NO;
	}

	void SetBase( grV2f& rMinMax )
	{
		grMath::RangeCheckV2f( rMinMax );
		Equal = grMath::CmpFloat( rMinMax.x, rMinMax.y ) ? EEqual::YES : EEqual::NO;
	}

	EEqual Equal;
};

struct grSColorGenerator : public grSGeneratorBase
{
	void Set( const grSColor& rStart, const grSColor& rEnd )
	{
		LocalStart = rStart;
		LocalEnd = rEnd;
		SetBase( LocalStart, LocalEnd );
	}

	void Generate( pU<grSParticle>& rParticle, const sizeT startIdx, const sizeT endIdx, const pU<grRandom>& rRand )
	{
		if ( Equal == grSGeneratorBase::EEqual::NO )
		{
			grV2u R, G, B, A;
			MinMaxRandAranger( LocalStart.R, LocalEnd.R, R );
			MinMaxRandAranger( LocalStart.G, LocalEnd.G, G );
			MinMaxRandAranger( LocalStart.B, LocalEnd.B, B );
			MinMaxRandAranger( LocalStart.A, LocalEnd.A, A );

			for ( sizeT i = startIdx; i < endIdx; ++i )
			{
				rParticle->puColorStart[ i ].R = LocalStart.R;
				rParticle->puColorStart[ i ].G = LocalStart.G;
				rParticle->puColorStart[ i ].B = LocalStart.B;
				rParticle->puColorStart[ i ].A = LocalStart.A;

				//rParticle->puColorStart[ i ].R = rRand->IntU( R.x, R.y );
				//rParticle->puColorStart[ i ].G = rRand->IntU( G.x, G.y );
				//rParticle->puColorStart[ i ].B = rRand->IntU( B.x, B.y );
				//rParticle->puColorStart[ i ].A = rRand->IntU( A.x, A.y );
			}

			for ( sizeT i = startIdx; i < endIdx; ++i )
			{
				rParticle->puColorEnd[ i ].R = LocalEnd.R;
				rParticle->puColorEnd[ i ].G = LocalEnd.G;
				rParticle->puColorEnd[ i ].B = LocalEnd.B;
				rParticle->puColorEnd[ i ].A = LocalEnd.A;
			}

			return;
		}

		for ( sizeT i = startIdx; i < endIdx; ++i )
		{
			rParticle->puColorStart[ i ].R = LocalStart.R;
			rParticle->puColorStart[ i ].G = LocalStart.G;
			rParticle->puColorStart[ i ].B = LocalStart.B;
			rParticle->puColorStart[ i ].A = LocalStart.A;
		}
	}

	void MinMaxRandAranger( const intU start, const intU end, grV2u& tmp )
	{
		if ( start < end )
		{
			tmp.x = start;
			tmp.y = end;
			return;
		}

		tmp.x = end;
		tmp.y = start;
	}

	grSColor	LocalStart,
				LocalEnd;
};

struct grSForceBasicGenerator : public grSGeneratorBase
{
	void Set( const grV2f& min, const grV2f& max )
	{
		LocalMin = min;
		LocalMax = max;
		SetBase( LocalMin, LocalMax );
	}

	void Generate( pU<grSParticle>& rParticle, const sizeT startIdx, const sizeT endIdx, const pU<grRandom>& rRand )
	{
		if ( Equal == grSGeneratorBase::EEqual::NO )
		{
			for ( sizeT i = startIdx; i < endIdx; ++i )
				rParticle->puAcceleration[ i ] += rRand->V2fx2( LocalMin, LocalMax );

			return;
		}

		for ( sizeT i = startIdx; i < endIdx; ++i )
			rParticle->puAcceleration[ i ] += LocalMin;
	}

	grV2f	LocalMin,
			LocalMax;
};

struct grSPositionGenerator : public grSGeneratorBase
{
	void Set( const grV2f& min, const grV2f& max )
	{
		LocalMin = min;
		LocalMax = max;
		SetBase( LocalMin, LocalMax );
	}

	void Generate( pU<grSParticle>& rParticle, const grV2f& positionSys, const sizeT startIdx, const sizeT endIdx, const pU<grRandom>& rRand )
	{
		if ( Equal == grSGeneratorBase::EEqual::NO )
		{
			for ( sizeT i = startIdx; i < endIdx; ++i )
				rParticle->puPosition[ i ] = grV2f( rRand->V2fx2( LocalMin, LocalMax ) ) + positionSys;

			return;
		}

		for ( sizeT i = startIdx; i < endIdx; ++i )
			rParticle->puPosition[ i ] = LocalMin + positionSys;
	}

	grV2f	LocalMin,
			LocalMax;
};

struct grSMassGenerator : public grSGeneratorBase
{
	void Set( const grV2f& rMinMax )
	{
		LocalMinMax = rMinMax;
		if ( LocalMinMax.x < 1.0f )
			LocalMinMax.x = 1.0f;

		SetBase( LocalMinMax );
	}

	void Generate( pU<grSParticle>& rParticle, const sizeT startIdx, const sizeT endIdx, const pU<grRandom>& rRand )
	{
		if ( Equal == grSGeneratorBase::EEqual::NO )
		{
			for ( sizeT i = startIdx; i < endIdx; ++i )
				rParticle->puMass[ i ] = rRand->Float( LocalMinMax.x, LocalMinMax.y );

			return;
		}

		for ( sizeT i = startIdx; i < endIdx; ++i )
			rParticle->puMass[ i ] = LocalMinMax.x;
	}

	grV2f LocalMinMax;
};

struct grSLifeGenerator : public grSGeneratorBase
{
	void Set( const grV2f& minMax )
	{
		LocalMinMax = minMax;
		if ( LocalMinMax.x < 0.0f )
			LocalMinMax.x = 0.0f;

		SetBase( LocalMinMax );
	}

	void Generate( pU<grSParticle>& rParticle, const sizeT startIdx, const sizeT endIdx, const pU<grRandom>& rRand )
	{
		if ( Equal == grSGeneratorBase::EEqual::NO )
		{
			for ( sizeT i = startIdx; i < endIdx; ++i )
				rParticle->puLife[ i ] = rRand->Float( LocalMinMax.x, LocalMinMax.y );

			return;
		}

		for ( sizeT i = startIdx; i < endIdx; ++i )
			rParticle->puLife[ i ] = LocalMinMax.x;
	}

	grV2f LocalMinMax;
};

struct grSEmitter
{
	grSEmitter( const grV2f position, const float emitRate, const sizeT size )
		: puRand		( std::make_unique<grRandom>() )
		, PositionSys	( position )
		, EmitRate		( emitRate )
		, SpawnAccT		( 0.0f )
		, EmitAcc		( 0 )
		, Size			( size )
	{}
	grSEmitter( const grSEmitter& ) = delete;
	grSEmitter& operator=( const grSEmitter& ) = delete;

	void Emit( pU<grSParticle>& rParticle, const float deltaT )
	{
		// This could be done smoother ex; NewSpawns = dt * SpawnRate
		// Problem is I haven't figured out how to make the spawnrate 'API' call non arbitrary in relation to real time, for example seconds

		// In case spawns per frame would be greater than frame time
		SpawnAccT += deltaT;
		while ( SpawnAccT >= EmitRate )
		{
			SpawnAccT -= EmitRate;
			EmitAcc += 1;
		}

		if ( EmitAcc > 0 )
		{
			sizeT startIdx, endIdx;
			startIdx = rParticle->Alive;
			endIdx = grMath::Min( rParticle->Alive + EmitAcc + 1, Size - 1 );

			// Increment particles alive
			rParticle->Alive += EmitAcc + 1;	// TODO: +1 should be needed so find bug

			if ( puColor )		puColor->Generate( rParticle, startIdx, endIdx, puRand );
			if ( puForceBasic )	puForceBasic->Generate( rParticle, startIdx, endIdx, puRand );
			if ( puPosition )	puPosition->Generate( rParticle,  PositionSys, startIdx, endIdx, puRand );
			if ( puMass )		puMass->Generate( rParticle, startIdx, endIdx, puRand );
			if ( puLife )		puLife->Generate( rParticle, startIdx, endIdx, puRand );
		}

		EmitAcc = 0;
	}

	// All types of generators goes here
	// No slow virtual stuff allowed so each generator has it's own place
	// TODO: If multiple generators of the same type would be allowed and produce cool results perhaps change to arrays
	pU<grSColorGenerator>		puColor;
	pU<grSForceBasicGenerator>	puForceBasic;
	pU<grSPositionGenerator>	puPosition;
	pU<grSMassGenerator>		puMass;
	pU<grSLifeGenerator>		puLife;

	pU<grRandom>	puRand;	// Is slightly greater than 5mb so instead of each generator containing one it's passed

	grV2f	PositionSys;
	float	EmitRate,
			SpawnAccT;
	sizeT	EmitAcc,
			Size;
};


////////////////////////////////////////////////////////////////////////////////////////////////////
struct grSColorUpdater
{
	void Update( pU<grSParticle>& rParticle, const float deltaT )
	{
		for ( sizeT i = 0; i < rParticle->Alive; ++i )
		{
			float lerpValue = 1.0f / rParticle->puLife[ i ] * deltaT;

			rParticle->puColorStart[ i ].R = ( intU )grMath::Lerp( rParticle->puColorStart[ i ].R, rParticle->puColorEnd[ i ].R, lerpValue );
			rParticle->puColorStart[ i ].G = ( intU )grMath::Lerp( rParticle->puColorStart[ i ].G, rParticle->puColorEnd[ i ].G, lerpValue );
			rParticle->puColorStart[ i ].B = ( intU )grMath::Lerp( rParticle->puColorStart[ i ].B, rParticle->puColorEnd[ i ].B, lerpValue );
			rParticle->puColorStart[ i ].A = ( intU )grMath::Lerp( rParticle->puColorStart[ i ].A, rParticle->puColorEnd[ i ].A, lerpValue );
		}
	}
};

struct grSForceBasicUpdater
{
	void Update( pU<grSParticle>& rParticle )
	{
		for ( sizeT i = 0; i < rParticle->Alive; ++i )
			rParticle->puVelocity[ i ] = rParticle->puAcceleration[ i ] / rParticle->puMass[ i ];
	}
};

struct grSPositionUpdater
{
	void Update( pU<grSParticle>& rParticle, const float deltaT )
	{
		for ( sizeT i = 0; i < rParticle->Alive; ++i )
			rParticle->puPosition[ i ] += rParticle->puVelocity[ i ] * deltaT;
	}
};

struct grSLifeUpdater
{
	void Update( pU<grSParticle>& rParticle, const float deltaT )
	{
		for ( sizeT i = 0; i < rParticle->Alive; ++i )
		{
			rParticle->puLife[ i ] -= deltaT;
			if ( rParticle->puLife[ i ] <= 0.0f )
				rParticle->Kill( i );
		}
	}
};

struct grSUpdater
{
	grSUpdater( void )
	: puPosition	( std::make_unique<grSPositionUpdater>() )
	{}
	grSUpdater( const grSUpdater& ) = delete;
	grSUpdater& operator=( const grSUpdater& ) = delete;

	void Update( pU<grSParticle>& rParticle, const float deltaT )
	{
		// TODO: Would be cool to not need the if's. Do not wan't the indirections from a virtual base so some type of eventlist might be an option
		// Update all updaters
		if ( puColor )		puColor->Update( rParticle, deltaT );
		if ( puForceBasic )	puForceBasic->Update( rParticle );
		if ( puPosition )	puPosition->Update( rParticle, deltaT );
		if ( puLife )		puLife->Update( rParticle, deltaT );
	}

	// No slow virtual stuff allowed so each updater has it's own place
	// All types of updaters goes here
	pU<grSColorUpdater>			puColor;
	pU<grSForceBasicUpdater>	puForceBasic;
	pU<grSPositionUpdater>		puPosition;
	pU<grSLifeUpdater>			puLife;
};

////////////////////////////////////////////////////////////////////////////////////////////////////
class grCParticleSys
{
public:
	grCParticleSys( const grV2f& position = grV2f( 320.0f, 180.0f ), const float emitRate = 1000.0f, const intU size = 5000 );
	grCParticleSys( const grCParticleSys& ) = delete;
	grCParticleSys& operator=( const grCParticleSys& ) = delete;

	void EmitRate( const float emitRate );
	void PositionSys( const grV2f& position );

	// If min<->max are equal, the value will be that. If not equal, the value will be rand inbetween
	// TODO: Could be better to use injection here as that would make it possible store behaviours externaly
	void Color( const grSColor& start, const grSColor& end );
	void ForceBasic( const grV2f& min, const grV2f& max );
	void PositionOffset( const grV2f& min, const grV2f& max );
	void Mass( const grV2f& minMax );
	void Life( const grV2f& minMax );

	// TODO: Remeber to make this call once in the particle manager whenever that class exists
	void Update( const float deltaT );

private:
	pU<grSParticle>	m_puParticle;
	pU<grSEmitter>	m_puEmitter;
	pU<grSUpdater>	m_puUpdater;

	// TODO: Needs activation choices for emission: start/stop/timer/infinite
};

#endif	// _GRPARTICLETEST_H_