#ifndef		_GRPARTICLETEST_H_
#define		_GRPARTICLETEST_H_

#include	"grCommon.h"
#include	"grV2.h"
#include	"grRandom.h"
#include	"grMath.h"
#include	"grAlgo.h"


////////////////////////////////////////////////////////////////////////////////////////////////////

//// Saved for later
//rPart.Color.r = rAtt.PartColMinMax.From.R;
//rPart.Color.g = rAtt.PartColMinMax.From.G;
//rPart.Color.b = rAtt.PartColMinMax.From.B;
//rPart.Color.a = rAtt.PartColMinMax.From.A;
//
//if ( rAtt.PartColMinMax.From != rAtt.PartColMinMax.Too )
//{
//	float r = ( float )rAtt.PartColMinMax.Too.R - ( float )rAtt.PartColMinMax.From.R;
//	float g = ( float )rAtt.PartColMinMax.Too.G - ( float )rAtt.PartColMinMax.From.G;
//	float b = ( float )rAtt.PartColMinMax.Too.B - ( float )rAtt.PartColMinMax.From.B;
//	float a = ( float )rAtt.PartColMinMax.Too.A - ( float )rAtt.PartColMinMax.From.A;
//
//	float t = rPart.Life * 60.0f;
//	rPart.ColRate.R = !grMath::CmpFloat( r, 0.0f ) ? r / t : 0.0f;
//	rPart.ColRate.G = !grMath::CmpFloat( g, 0.0f ) ? g / t : 0.0f;
//	rPart.ColRate.B = !grMath::CmpFloat( b, 0.0f ) ? b / t : 0.0f;
//	rPart.ColRate.A = !grMath::CmpFloat( a, 0.0f ) ? a / t : 0.0f;
//}


struct grSColor
{
	grSColor( void )
		: R( 255 )
		, G( 255 )
		, B( 255 )
		, A( 1.0f )
	{}

	float	A;
	intU	R, G, B;
};


////////////////////////////////////////////////////////////////////////////////////////////////////
struct grSParticle
{
	grSParticle( const sizeT size )
		: puColor			( std::make_unique<grSColor[]>( size ) )
		, puScale			( std::make_unique<grV2f[]>( size ) )
		, puAcceleration	( std::make_unique<grV2f[]>( size ) )
		, puVelocity		( std::make_unique<grV2f[]>( size ) )
		, puPosition		( std::make_unique<grV2f[]>( size ) )
		, puMass			( std::make_unique<float[]>( size ) )
		, puLife			( std::make_unique<float[]>( size ) )
		, Alive				( 0 )
	{}
	grSParticle( const grSParticle& ) = delete;
	grSParticle& operator=( const grSParticle& ) = delete;

	void Kill( const sizeT nowIdx )
	{
		sizeT last = Alive - 1;

		//for( sizeT i = 0; i < rParticle->Alive + 1; ++i )
		//	printf( "%d %3s %g \n", i, "", rParticle->puLife[ i ] );

		grAlgo::Swap( puColor[ nowIdx ], puColor[ last ] );
		grAlgo::Swap( puScale[ nowIdx ], puScale[ last ] );
		grAlgo::Swap( puAcceleration[ nowIdx ], puAcceleration[ last ] );
		grAlgo::Swap( puVelocity[ nowIdx ], puVelocity[ last ] );
		grAlgo::Swap( puPosition[ nowIdx ], puPosition[ last ] );
		grAlgo::Swap( puMass[ nowIdx ], puMass[ last ] );
		grAlgo::Swap( puLife[ nowIdx ], puLife[ last ] );

		// Most values are generated by operator= and does not need zeroing
		// Values that are generated with operator+= needs resetting obviously

		puAcceleration[ last ] = grV2f();

		//for ( sizeT i = 0; i < rParticle->Alive + 1; ++i )
		//	printf( "%d %3s %g \n", i, "", rParticle->puLife[ i ] );

		--Alive;
	}

	pU<grSColor[]>	puColor;
	pU<grV2f[]>		puScale;
	pU<grV2f[]>		puAcceleration;
	pU<grV2f[]>		puVelocity;
	pU<grV2f[]>		puPosition;
	pU<float[]>		puMass;
	pU<float[]>		puLife;

	sizeT	Alive;
};


////////////////////////////////////////////////////////////////////////////////////////////////////
struct grSGeneratorBase
{
	enum class EEqual
	{
		NO = 0,
		YES = 1
	};

	// Point of struct is to have memory uniformity between different generators and easily do padding
	grSGeneratorBase( const grV2f& min = grV2f(), const grV2f& max = grV2f() )
		: Min	( min )
		, Max	( max )
		, Equal	( EEqual::YES )
	{}

	grV2f	Min,
			Max;
	EEqual	Equal;
};


struct grSLifeGenerator : public grSGeneratorBase
{
	void Set( const grV2f& minMax )
	{
		Min = minMax;

		if ( Min.x < 0.0f )
			Min.x = 0.0f;

		if ( Min.x > Min.y )
			Min.y = Min.x;

		if ( grMath::CmpFloat( Min.x, Min.y ) == false )
			Equal = EEqual::NO;
	}

	void Generate( pU<grSParticle>& rParticle, const sizeT startIdx, const sizeT endIdx, const pU<grRandom>& rRand, const float deltaT )
	{
		switch ( Equal )
		{
			case EEqual::NO:
			for ( sizeT i = startIdx; i < endIdx; ++i )
				rParticle->puLife[ i ] = rRand->Float( Min.x, Min.y );
			break;

			case EEqual::YES:
			for ( sizeT i = startIdx; i < endIdx; ++i )
				rParticle->puLife[ i ] = Min.x;
			break;
		}
	}
};


struct grSForceBasicGenerator : public grSGeneratorBase
{
	void Set( const grV2f& min, const grV2f& max )
	{
		Min = min;
		Max = max;

		grMath::RangeCheckPairV2f( Min, Max );

		if ( grMath::CmpV2f( Min, Max ) == false )
			Equal = EEqual::NO;
	}

	void Generate( pU<grSParticle>& rParticle, const sizeT startIdx, const sizeT endIdx, const pU<grRandom>& rRand, const float deltaT )
	{
		switch ( Equal )
		{
			case EEqual::NO:
			for ( sizeT i = startIdx; i < endIdx; ++i )
				rParticle->puAcceleration[ i ] += rRand->V2fx2( Min, Max );
			break;

			case EEqual::YES:
			for ( sizeT i = startIdx; i < endIdx; ++i )
				rParticle->puAcceleration[ i ] += Min;
			break;
		}
	}
};


struct grSPositionGenerator : public grSGeneratorBase
{
	void Set( const grV2f& min, const grV2f& max )
	{
		Min = min;
		Max = max;

		grMath::RangeCheckPairV2f( Min, Max );

		if ( grMath::CmpV2f( Min, Max ) == false )
			Equal = EEqual::NO;
	}

	void Generate( pU<grSParticle>& rParticle, const grV2f& positionSys, const sizeT startIdx, const sizeT endIdx, const pU<grRandom>& rRand, const float deltaT )
	{
		switch ( Equal )
		{
			case EEqual::NO:
			for ( sizeT i = startIdx; i < endIdx; ++i )
				rParticle->puPosition[ i ] = grV2f( rRand->V2fx2( Min, Max ) ) + positionSys;
			break;

			case EEqual::YES:
			for ( sizeT i = startIdx; i < endIdx; ++i )
				rParticle->puPosition[ i ] = Min + positionSys;
			break;
		}
	}
};


struct grSEmitter
{
	grSEmitter( const float emitRate, const sizeT size )
		: puRand			( std::make_unique<grRandom>() )
		, PositionSys		( grV2f() )
		, EmitRate			( emitRate )
		, SpawnAccT			( 0.0f )
		, EmitAcc			( 0 )
		, MaxParticleSize	( size )
	{}
	grSEmitter( const grSEmitter& ) = delete;
	grSEmitter& operator=( const grSEmitter& ) = delete;

	void Emit( pU<grSParticle>& rParticle, const float deltaT )
	{
		// This could be done smoother ex; NewSpawns = dt * SpawnRate
		// Problem then is I haven't figured out how to make the spawnrate 'API' call non arbitrary in relation to real time, for example seconds

		// Done like this in case spawns per frame would be greater than frame time
		SpawnAccT += deltaT;
		while ( SpawnAccT >= EmitRate )
		{
			SpawnAccT -= EmitRate;
			EmitAcc += 1;
		}

		if ( EmitAcc > 0 )
		{
			// Find array indices
			sizeT startIdx, endIdx;
			startIdx = rParticle->Alive;
			endIdx = grMath::Min( rParticle->Alive + EmitAcc + 1, MaxParticleSize - 1 );

			// Increment particles alive
			rParticle->Alive += EmitAcc + 1;	// TODO: +1 should be needed so find bug

			// Update all generators
			if ( puLife )		puLife->Generate( rParticle, startIdx, endIdx, puRand, deltaT );
			if ( puForceBasic )	puForceBasic->Generate( rParticle, startIdx, endIdx, puRand, deltaT );
			if ( puPosition )	puPosition->Generate( rParticle, PositionSys, startIdx, endIdx, puRand, deltaT );
		}

		EmitAcc = 0;
	}

	// All types of generators goes here
	// No slow virtual stuff allowed so each generator has it's own place
	// TODO: If multiple generators of the same type would be allowed and produce cool results perhaps change to arrays
	pU<grSLifeGenerator>		puLife;
	pU<grSForceBasicGenerator>	puForceBasic;
	pU<grSPositionGenerator>	puPosition;

	pU<grRandom>	puRand;	// Is slightly greater then 5mb so instead of each generator containing one it's passed

	grV2f	PositionSys;
	float	EmitRate,
			SpawnAccT;
	sizeT	EmitAcc,
			MaxParticleSize;
};


////////////////////////////////////////////////////////////////////////////////////////////////////
struct grSLifeUpdater
{
	void Update( pU<grSParticle>& rParticle, const float deltaT )
	{
		for ( sizeT i = 0; i < rParticle->Alive; ++i )
		{
			rParticle->puLife[ i ] -= deltaT;
			if ( rParticle->puLife[ i ] <= 0.0f )
				rParticle->Kill( i );
		}
	}
};


struct grSForceBasicUpdater
{
	void Update( pU<grSParticle>& rParticle, const float deltaT )
	{
		for ( sizeT i = 0; i < rParticle->Alive; ++i )
			rParticle->puVelocity[ i ] = rParticle->puAcceleration[ i ];
	}
};


struct grSPositionUpdater
{
	void Update( pU<grSParticle>& rParticle, const float deltaT )
	{
		for ( sizeT i = 0; i < rParticle->Alive; ++i )
			rParticle->puPosition[ i ] += rParticle->puVelocity[ i ] * deltaT;
	}
};


struct grSUpdater
{
	grSUpdater( void ) {}
	grSUpdater( const grSUpdater& ) = delete;
	grSUpdater& operator=( const grSUpdater& ) = delete;

	void Update( pU<grSParticle>& rParticle, const float deltaT )
	{
		// TODO: Would be cool to not need the if's. Do not wan't the indirections from a virtual base so some type of eventlist might be an option
		// Update all updaters
		if ( puLife )		puLife->Update( rParticle, deltaT );
		if ( puForceBasic )	puForceBasic->Update( rParticle, deltaT );
		if ( puPosition )	puPosition->Update( rParticle, deltaT );
	}

	// No slow virtual stuff allowed so each updater has it's own place
	// All types of updaters goes here
	pU<grSLifeUpdater>			puLife;
	pU<grSForceBasicUpdater>	puForceBasic;
	pU<grSPositionUpdater>		puPosition;
};


////////////////////////////////////////////////////////////////////////////////////////////////////
class grCParticleSys
{
public:
	grCParticleSys( const intU particleSize = 5000, const float emitRate = 1000.0f, const grV2f& position = grV2f( 320.0f, 180.0f ) );
	grCParticleSys( const grCParticleSys& ) = delete;
	grCParticleSys& operator=( const grCParticleSys& ) = delete;

	void PositionSys( const grV2f& position );
	void EmitRate( const float emitRate );

	// If min<->max are equal, the value will be that. If not equal, the value will be rand inbetween
	// TODO: Could be better to use injection here as that would make it possible store behaviours externaly
	void Life( const grV2f& minMax );
	void ForceBasic( const grV2f& min, const grV2f& max );
	void PositionOffset( const grV2f& min, const grV2f& max );

	// TODO: Remeber to make this call once in the particle manager whenever that class exists
	void Update( const float deltaT );

private:
	pU<grSParticle>	m_puParticle;
	pU<grSEmitter>	m_puEmitter;
	pU<grSUpdater>	m_puUpdater;

	// TODO: Needs emit activation chioce, start/stop/timer/infinite
};

#endif	// _GRPARTICLETEST_H_