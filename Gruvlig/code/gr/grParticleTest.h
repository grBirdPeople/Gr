#ifndef		_GRPARTICLETEST_H_
#define		_GRPARTICLETEST_H_

#include	"grCommon.h"
#include	"grV2.h"
#include	"grRandom.h"
#include	"grAlgo.h"
#include	"grColor.h"
#include	"grStruct.h"


////////////////////////////////////////////////////////////////////////////////////////////////////
typedef grColor::SRgba SRgba;

struct grSParticle
{
	grSParticle( const sizeT size )
		: puColorStart		( std::make_unique<SRgba[]>( size ) )
		, puColorEnd		( std::make_unique<SRgba[]>( size ) )
		, puScale			( std::make_unique<grV2f[]>( size ) )		
		, puAcceleration	( std::make_unique<grV2f[]>( size ) )
		, puVelocity		( std::make_unique<grV2f[]>( size ) )
		, puPosition		( std::make_unique<grV2f[]>( size ) )
		, puMass			( std::make_unique<float[]>( size ) )
		, puLife			( std::make_unique<float[]>( size ) )
		, Alive				( 0 )
	{
		for( sizeT i = 0; i < size; ++i )
			puMass[ i ] = 1.0f;

		//// TEST: Unique ptr dynamic array 2D
		//pU<pU<int[]>[]> smartPtr2D = std::make_unique<pU<int[]>[]>( 3 );
		//for ( sizeT i = 0; i < 3; ++i )
		//{
		//	pU<int[]> smartPtr1D = std::make_unique<int[]>( 3 );
		//	for ( sizeT j = 0; j < 3; ++j )
		//		smartPtr1D[ j ] = j;

		//	smartPtr2D[ i ] = std::move( smartPtr1D );
		//}
		//// TEST
	}
	grSParticle( const grSParticle& ) = delete;
	grSParticle& operator=( const grSParticle& ) = delete;

	inline void Kill( const sizeT nowIdx )
	{
		sizeT last = Alive - 1;

		//for( sizeT i = 0; i < rParticle->Alive + 1; ++i )
		//	printf( "%d %3s %g \n", i, "", rParticle->puLife[ i ] );

		grAlgo::Swap( puColorStart[ nowIdx ], puColorStart[ last ] );
		grAlgo::Swap( puColorEnd[ nowIdx ], puColorEnd[ last ] );
		grAlgo::Swap( puScale[ nowIdx ], puScale[ last ] );
		grAlgo::Swap( puAcceleration[ nowIdx ], puAcceleration[ last ] );
		grAlgo::Swap( puVelocity[ nowIdx ], puVelocity[ last ] );
		grAlgo::Swap( puPosition[ nowIdx ], puPosition[ last ] );
		grAlgo::Swap( puMass[ nowIdx ], puMass[ last ] );
		grAlgo::Swap( puLife[ nowIdx ], puLife[ last ] );

		// Most values are generated by operator= and does not need zeroing
		// Values that are generated with operator+= needs resetting obviously

		puAcceleration[ last ] = grV2f();

		//for ( sizeT i = 0; i < rParticle->Alive + 1; ++i )
		//	printf( "%d %3s %g \n", i, "", rParticle->puLife[ i ] );

		--Alive;
	}

	pU<SRgba[]>	puColorStart;
	pU<SRgba[]>	puColorEnd;
	pU<grV2f[]>	puScale;
	pU<grV2f[]>	puAcceleration;
	pU<grV2f[]>	puVelocity;
	pU<grV2f[]>	puPosition;
	pU<float[]>	puMass;
	pU<float[]>	puLife;

	sizeT	Alive;
};

////////////////////////////////////////////////////////////////////////////////////////////////////
struct grSGeneratorBase
{
	enum class EEqual
	{
		NO = 0,
		YES = 1
	};

	inline void SetBase( grColor::SRgba& rStart, grColor::SRgba& rEnd )
	{
		rStart.R = grMath::Clamp( rStart.R, 0, 255 );
		rStart.G = grMath::Clamp( rStart.G, 0, 255 );
		rStart.B = grMath::Clamp( rStart.B, 0, 255 );
		rStart.A = grMath::Clamp( rStart.A, 0, 255 );

		rEnd.R = grMath::Clamp( rEnd.R, 0, 255 );
		rEnd.G = grMath::Clamp( rEnd.G, 0, 255 );
		rEnd.B = grMath::Clamp( rEnd.B, 0, 255 );
		rEnd.A = grMath::Clamp( rEnd.A, 0, 255 );

		if ( grMath::CmpFloat( rStart.R, rEnd.R ) &&
			 grMath::CmpFloat( rStart.G, rEnd.G ) &&
			 grMath::CmpFloat( rStart.B, rEnd.B ) &&
			 grMath::CmpFloat( rStart.A, rEnd.A ) )
		{
			Equal = EEqual::YES;
		}
	}

	inline void SetBase( grV2f& rMin, grV2f& rMax )
	{
		grMath::RangeCheckV2fx2( rMin, rMax );
		Equal = grMath::CmpV2f( rMin, rMax ) ? EEqual::YES : EEqual::NO;
	}

	inline void SetBase( grV2f& rMinMax )
	{
		grMath::RangeCheckV2f( rMinMax );
		Equal = grMath::CmpFloat( rMinMax.x, rMinMax.y ) ? EEqual::YES : EEqual::NO;
	}

	EEqual Equal;
};

struct grSColorGenerator : public grSGeneratorBase
{
	inline void Set( const grColor::SRgba& rStart, const grColor::SRgba& rEnd, const bool randomize )
	{
		LocalStart = rStart;
		LocalEnd = rEnd;
		Rand = randomize;
		SetBase( LocalStart, LocalEnd );
	}

	inline void Generate( pU<grSParticle>& rParticle, const sizeT startIdx, const sizeT endIdx, const pU<grRandom>& rRand )
	{
		if ( Rand )
		{
			float midR = grMath::Abs( LocalStart.R - LocalEnd.R ) * 0.5f;
			float midG = grMath::Abs( LocalStart.G - LocalEnd.G ) * 0.5f;
			float midB = grMath::Abs( LocalStart.B - LocalEnd.B ) * 0.5f;
			//float midA = grMath::Abs( LocalStart.A - LocalEnd.A ) * 0.5f;		// Don't think I like random alpha

			for ( sizeT i = startIdx; i < endIdx; ++i )
			{
				rParticle->puColorStart[ i ].R = LocalStart.R > midR ? rRand->Float( midR, LocalStart.R ) : rRand->Float( LocalStart.R, midR );
				rParticle->puColorStart[ i ].G = LocalStart.G > midG ? rRand->Float( midG, LocalStart.G ) : rRand->Float( LocalStart.G, midG );
				rParticle->puColorStart[ i ].B = LocalStart.B > midB ? rRand->Float( midB, LocalStart.B ) : rRand->Float( LocalStart.B, midB );
				rParticle->puColorStart[ i ].A = LocalStart.A;
			}

			for ( sizeT i = startIdx; i < endIdx; ++i )
			{
				rParticle->puColorEnd[ i ].R = LocalEnd.R > midR ? rRand->Float( midR, LocalEnd.R ) : rRand->Float( LocalEnd.R, midR );
				rParticle->puColorEnd[ i ].G = LocalEnd.G > midG ? rRand->Float( midG, LocalEnd.G ) : rRand->Float( LocalEnd.G, midG );
				rParticle->puColorEnd[ i ].B = LocalEnd.B > midB ? rRand->Float( midB, LocalEnd.B ) : rRand->Float( LocalEnd.B, midB );
				rParticle->puColorEnd[ i ].A = LocalEnd.A;
			}

			return;
		}
		
		for ( sizeT i = startIdx; i < endIdx; ++i )
		{
			rParticle->puColorStart[ i ].R = LocalStart.R;
			rParticle->puColorStart[ i ].G = LocalStart.G;
			rParticle->puColorStart[ i ].B = LocalStart.B;
			rParticle->puColorStart[ i ].A = LocalStart.A;
		}

		for ( sizeT i = startIdx; i < endIdx; ++i )
		{
			rParticle->puColorEnd[ i ].R = LocalEnd.R;
			rParticle->puColorEnd[ i ].G = LocalEnd.G;
			rParticle->puColorEnd[ i ].B = LocalEnd.B;
			rParticle->puColorEnd[ i ].A = LocalEnd.A;
		}
	}

	SRgba	LocalStart,
			LocalEnd;
	bool	Rand;
};

struct grSForceBasicGenerator : public grSGeneratorBase
{
	inline void Set( const grV2f& min, const grV2f& max )
	{
		LocalMin = min;
		LocalMax = max;
		SetBase( LocalMin, LocalMax );
	}

	inline void Generate( pU<grSParticle>& rParticle, const sizeT startIdx, const sizeT endIdx, const pU<grRandom>& rRand )
	{
		if ( Equal == grSGeneratorBase::EEqual::NO )
		{
			for ( sizeT i = startIdx; i < endIdx; ++i )
				rParticle->puAcceleration[ i ] += rRand->V2fx2( LocalMin, LocalMax );

			return;
		}

		for ( sizeT i = startIdx; i < endIdx; ++i )
			rParticle->puAcceleration[ i ] += LocalMin;
	}

	grV2f	LocalMin,
			LocalMax;
};

struct grSPositionGenerator : public grSGeneratorBase
{
	inline void Set( const grV2f& min, const grV2f& max )
	{
		LocalMin = min;
		LocalMax = max;
		SetBase( LocalMin, LocalMax );
	}

	inline void Generate( pU<grSParticle>& rParticle, const grV2f& positionSys, const sizeT startIdx, const sizeT endIdx, const pU<grRandom>& rRand )
	{
		if ( Equal == grSGeneratorBase::EEqual::NO )
		{
			for ( sizeT i = startIdx; i < endIdx; ++i )
				rParticle->puPosition[ i ] = grV2f( rRand->V2fx2( LocalMin, LocalMax ) ) + positionSys;

			return;
		}

		for ( sizeT i = startIdx; i < endIdx; ++i )
			rParticle->puPosition[ i ] = LocalMin + positionSys;
	}

	grV2f	LocalMin,
			LocalMax;
};

struct grSMassGenerator : public grSGeneratorBase
{
	inline void Set( const grV2f& rMinMax )
	{
		LocalMinMax = rMinMax;
		if ( LocalMinMax.x < 1.0f )
			LocalMinMax.x = 1.0f;

		SetBase( LocalMinMax );
	}

	inline void Generate( pU<grSParticle>& rParticle, const sizeT startIdx, const sizeT endIdx, const pU<grRandom>& rRand )
	{
		if ( Equal == grSGeneratorBase::EEqual::NO )
		{
			for ( sizeT i = startIdx; i < endIdx; ++i )
				rParticle->puMass[ i ] = rRand->Float( LocalMinMax.x, LocalMinMax.y );

			return;
		}

		for ( sizeT i = startIdx; i < endIdx; ++i )
			rParticle->puMass[ i ] = LocalMinMax.x;
	}

	grV2f LocalMinMax;
};

struct grSLifeGenerator : public grSGeneratorBase
{
	inline void Set( const grV2f& minMax )
	{
		LocalMinMax = minMax;
		if ( LocalMinMax.x < 0.0f )
			LocalMinMax.x = 0.0f;

		SetBase( LocalMinMax );
	}

	inline void Generate( pU<grSParticle>& rParticle, const sizeT startIdx, const sizeT endIdx, const pU<grRandom>& rRand )
	{
		if ( Equal == grSGeneratorBase::EEqual::NO )
		{
			for ( sizeT i = startIdx; i < endIdx; ++i )
				rParticle->puLife[ i ] = rRand->Float( LocalMinMax.x, LocalMinMax.y );

			return;
		}

		for ( sizeT i = startIdx; i < endIdx; ++i )
			rParticle->puLife[ i ] = LocalMinMax.x;
	}

	grV2f LocalMinMax;
};

struct grSEmitter
{
	grSEmitter( const grV2f position, const float emitRate, const sizeT size )
		: puRand		( std::make_unique<grRandom>() )
		, PositionSys	( position )
		, EmitRate		( emitRate )
		, SpawnAccT		( 0.0f )
		, EmitAcc		( 0 )
		, Size			( size )
	{}
	grSEmitter( const grSEmitter& ) = delete;
	grSEmitter& operator=( const grSEmitter& ) = delete;

	inline void Emit( pU<grSParticle>& rParticle, const float deltaT ) noexcept
	{
		// This could be done smoother ex; NewSpawns = dt * SpawnRate
		// Problem is I haven't figured out how to make the spawnrate 'API' call non arbitrary in relation to real time, for example seconds

		// In case spawns per frame would be greater than frame time
		SpawnAccT += deltaT;
		while ( SpawnAccT >= EmitRate )
		{
			SpawnAccT -= EmitRate;
			EmitAcc += 1;
		}

		if ( EmitAcc > 0 )
		{
			sizeT startIdx = rParticle->Alive;
			sizeT endIdx = grMath::Min( rParticle->Alive + EmitAcc + 1, Size - 1 );

			// Increment particles alive
			rParticle->Alive += EmitAcc + 1;	// TODO: +1 should be needed so find bug

			if ( puColor )		puColor->Generate( rParticle, startIdx, endIdx, puRand );
			if ( puForceBasic )	puForceBasic->Generate( rParticle, startIdx, endIdx, puRand );
			if ( puPosition )	puPosition->Generate( rParticle,  PositionSys, startIdx, endIdx, puRand );
			if ( puMass )		puMass->Generate( rParticle, startIdx, endIdx, puRand );
			if ( puLife )		puLife->Generate( rParticle, startIdx, endIdx, puRand );
		}

		EmitAcc = 0;
	}

	// All types of generators goes here
	// No slow virtual stuff allowed so each generator has it's own place
	// TODO: If multiple generators of the same type would be allowed and produce cool results perhaps change to arrays
	pU<grSColorGenerator>		puColor;
	pU<grSForceBasicGenerator>	puForceBasic;
	pU<grSPositionGenerator>	puPosition;
	pU<grSMassGenerator>		puMass;
	pU<grSLifeGenerator>		puLife;

	pU<grRandom>	puRand;	// Is slightly greater than 5mb so instead of each generator containing one it's passed

	grV2f	PositionSys;
	float	EmitRate,
			SpawnAccT;
	sizeT	EmitAcc,
			Size;
};


////////////////////////////////////////////////////////////////////////////////////////////////////
struct grSColorUpdater
{
	grSColorUpdater( const bool hsv )
		: Hsv	( hsv )
	{}

	inline void Update( pU<grSParticle>& rParticle, const float deltaT )
	{
		if ( Hsv )
		{
			for ( sizeT i = 0; i < rParticle->Alive; ++i )
			{
				float lerpValue = 1.0f / rParticle->puLife[ i ] * deltaT;

				// RGB -> HSV lerp -> RGB
				grColor::SHsva start = grColor::Rgba2Hsva( rParticle->puColorStart[ i ] );
				grColor::SHsva end = grColor::Rgba2Hsva( rParticle->puColorEnd[ i ] );

				start.H = grMath::Lerp( start.H, end.H, lerpValue );
				start.S = grMath::Lerp( start.S, end.S, lerpValue );
				start.V = grMath::Lerp( start.V, end.V, lerpValue );
				start.A = grMath::Lerp( start.A, end.A, lerpValue );

				rParticle->puColorStart[ i ] = grColor::Hsva2Rgba( start );
			}

			return;
		}

		for ( sizeT i = 0; i < rParticle->Alive; ++i )
		{
			float lerpValue = 1.0f / rParticle->puLife[ i ] * deltaT;

			// Actually faster to store localy and passing to lerp then passing directly by indexing the array. Cache friendlier?
			// Measured with grStruct::STimerOneShot t( grStruct::STimerOneShot::ETimer::MS );
			grColor::SRgba start = rParticle->puColorStart[ i ];
			grColor::SRgba end = rParticle->puColorEnd[ i ];

			rParticle->puColorStart[ i ].R = grMath::Lerp( start.R, end.R, lerpValue );
			rParticle->puColorStart[ i ].G = grMath::Lerp( start.G, end.G, lerpValue );
			rParticle->puColorStart[ i ].B = grMath::Lerp( start.B, end.B, lerpValue );
			rParticle->puColorStart[ i ].A = grMath::Lerp( start.A, end.A, lerpValue );
		}
	}

	bool Hsv;
};

struct grSForceBasicUpdater
{
	inline void Update( pU<grSParticle>& rParticle )
	{
		for ( sizeT i = 0; i < rParticle->Alive; ++i )
			rParticle->puVelocity[ i ] = rParticle->puAcceleration[ i ] / rParticle->puMass[ i ];
	}
};

struct grSPositionUpdater
{
	inline void Update( pU<grSParticle>& rParticle, const float deltaT )
	{
		for ( sizeT i = 0; i < rParticle->Alive; ++i )
			rParticle->puPosition[ i ] += rParticle->puVelocity[ i ] * deltaT;
	}
};

struct grSLifeUpdater
{
	inline void Update( pU<grSParticle>& rParticle, const float deltaT )
	{
		for ( sizeT i = 0; i < rParticle->Alive; ++i )
		{
			rParticle->puLife[ i ] -= deltaT;
			if ( rParticle->puLife[ i ] <= 0.0f )
				rParticle->Kill( i );
		}
	}
};

struct grSUpdater
{
	grSUpdater( void )
	: puPosition	( std::make_unique<grSPositionUpdater>() )
	{}
	grSUpdater( const grSUpdater& ) = delete;
	grSUpdater& operator=( const grSUpdater& ) = delete;

	inline void Update( pU<grSParticle>& rParticle, const float deltaT )
	{
		// TODO: Would be cool to not need the if's. Do not wan't the indirections from a virtual base so some type of eventlist might be an option
		// Update all updaters
		if ( puColor )		puColor->Update( rParticle, deltaT );
		if ( puForceBasic )	puForceBasic->Update( rParticle );
		if ( puPosition )	puPosition->Update( rParticle, deltaT );
		if ( puLife )		puLife->Update( rParticle, deltaT );
	}

	// No slow virtual stuff allowed so each updater has it's own place
	// All types of updaters goes here
	pU<grSColorUpdater>			puColor;
	pU<grSForceBasicUpdater>	puForceBasic;
	pU<grSPositionUpdater>		puPosition;
	pU<grSLifeUpdater>			puLife;
};

////////////////////////////////////////////////////////////////////////////////////////////////////
class grCParticleSys
{
public:
	grCParticleSys( const grV2f& position = grV2f( 320.0f, 180.0f ), const float emitRate = 1000.0f, const intU size = 5000 );
	grCParticleSys( const grCParticleSys& ) = delete;
	grCParticleSys& operator=( const grCParticleSys& ) = delete;

	void EmitRate( const float emitRate );
	void PositionSys( const grV2f& position );

	// If min<->max are equal, the value will be that. If not equal, the value will be rand inbetween
	// TODO: Could be better to use injection here as that would make it possible store behaviours externaly
	void Color( const grColor::SRgba& start, const grColor::SRgba& end, const bool hsv = false, const bool randomize = false );
	void ForceBasic( const grV2f& min, const grV2f& max );
	void PositionOffset( const grV2f& min, const grV2f& max );
	void Mass( const grV2f& minMax );
	void Life( const grV2f& minMax );

	// TODO: Remeber to make this call once in the particle manager whenever that class exists
	void Update( const float deltaT );

private:
	pU<grSParticle>	m_puParticle;
	pU<grSEmitter>	m_puEmitter;
	pU<grSUpdater>	m_puUpdater;

	// TODO: Needs activation choices for emission: start/stop/timer/infinite
};

#endif	// _GRPARTICLETEST_H_